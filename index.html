<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>なんちゃってレアガチャロールズ</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #controls label, #controls input, #controls button { margin-right: 10px; margin-bottom: 10px; display: inline-block; }
        .error { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; table-layout: fixed; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th:not(.col-no):not(.seed-column), td:not(.col-no):not(.seed-column) { width: 100%; }
        th { background-color: #f2f2f2; text-align: center; vertical-align: middle; position: relative; }
        .highlight { background-color: #ffff99; }
        .gacha-select-header { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; }
        .gacha-select-header span { margin-left: 5px; font-size: 12px; }
        .gacha-select-header select {
            width: 20px; /* 幅を最小に */
            -webkit-appearance: none; /* Safari, Chrome */
            -moz-appearance: none; /* Firefox */
            appearance: none; /* 標準 */
            background: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right / .8em; /* 矢印アイコン */
            padding-right: 1em; /* アイコンのスペース */
        }
        .gacha-select-header button { font-size: 10px; padding: 2px 4px; margin-left: 4px; }
        .add-gacha-btn { font-size: 12px; font-weight: normal; padding: 2px 6px; margin-left: 15px; }
        #result { margin-top: 20px; border: 1px solid #ccc; padding: 10px; white-space: pre-wrap; font-family: monospace; background-color: #f9f9f9; max-height: 300px; overflow-y: auto; }
        #table-actions { text-align: center; margin-top: 20px; }
        #table-actions button { margin: 0 5px; }

        /* Toggle visibility classes */
        .hidden { display: none; }
        .seed-column { width: 90px; text-align: center; font-size: 10px; color: #555; }
        .col-no { width: 45px; text-align: center; white-space: nowrap; }
    </style>
</head>
<body>
    <h1>なんちゃってGachaRolls（gr）シミュレーター（レアロールズ）</h1>

    <div id="controls">
        <label for="seed">SEED:</label>
        <input type="number" id="seed" value="12345" min="1" max="4294967295" onchange="resetAndGenerateTable()">
        <button onclick="updateSeedFromSim()">SEED更新</button>
        <label for="sim-config">シミュレーション:</label>
        <input type="text" id="sim-config" placeholder="ガチャID-ロール数" onchange="resetAndGenerateTable()">
    </div>

    <div id="rolls-table-container"></div>
    <div id="table-actions">
        <button onclick="addMoreRows(100)">100行追加する</button>
        <button id="toggle-seed-btn" onclick="toggleSeedColumns()">SEEDを表示</button>
        <button id="toggle-result-btn" onclick="toggleResultDisplay()">計算過程を表示</button>
    </div>
    <div id="result"></div>

    <script>
        let gachaMasterData = {};
        const dataFiles = ['data/cats.js', 'data/events.js', 'data/gacha.js'];
        let tableGachaIds = [];
        let currentRolls = 100;
        let showSeedColumns = false;
        let showResultDisplay = false;
        let finalSeedForUpdate = null; // SEED更新ボタン用

        const fallbackCats = [
            {id:31,name:"ネコぼさつ",rarity:3},{id:32,name:"ネコ番長",rarity:3},{id:33,name:"ネコザイル",rarity:3},{id:34,name:"ねこタツ",rarity:3},{id:35,name:"ネコルガ",rarity:4},{id:36,name:"オタネコ",rarity:3},{id:37,name:"ネコスイマー",rarity:3},{id:38,name:"ネコホッピング",rarity:2},{id:39,name:"ネコ車輪",rarity:2},{id:40,name:"ネコリンゴ",rarity:3},{id:41,name:"ネコバスたぶ",rarity:3},{id:42,name:"ネコエステ",rarity:2},{id:43,name:"ネコアイス",rarity:4},{id:44,name:"ネコマシン",rarity:4},{id:45,name:"鬼にゃんま",rarity:4},{id:47,name:"ねこジュラ",rarity:2},{id:48,name:"ねこファイター",rarity:2},{id:49,name:"ねこ海賊",rarity:2},{id:50,name:"ねこ泥棒",rarity:2},{id:51,name:"ねこ僧侶",rarity:2},{id:52,name:"ねこ占い師",rarity:2},{id:53,name:"ネコシャーマン",rarity:2},{id:56,name:"ネコ魔女",rarity:2},{id:57,name:"ネコアーチャー",rarity:2},{id:58,name:"ネコシュバリエ",rarity:4},{id:59,name:"ネコ魔剣士",rarity:2},{id:60,name:"ねこベビー",rarity:4},{id:62,name:"ねこ寿司",rarity:3},{id:76,name:"風神のウィンディ",rarity:4},{id:84,name:"地龍ソドム",rarity:4},{id:85,name:"聖龍メギドラ",rarity:4},{id:107,name:"召し豚のカイ",rarity:4},{id:108,name:"宝杖のカッパーマイン",rarity:4},{id:130,name:"金ネコ",rarity:3},{id:132,name:"ねねこ",rarity:3},{id:136,name:"ツルの恩返し",rarity:4},{id:144,name:"ねこナース",rarity:4},{id:145,name:"にゃんこ城Mini",rarity:3},{id:146,name:"ねこガンマン",rarity:2},{id:147,name:"たけうまねこ",rarity:2},{id:148,name:"ブリキネコ",rarity:2},{id:149,name:"ねこロッカー",rarity:2},{id:150,name:"ねこ人魚",rarity:2},{id:151,name:"窓辺の乙女ネコ",rarity:3},{id:152,name:"ネコバーベル",rarity:3},{id:153,name:"ネコスケート",rarity:3},{id:154,name:"ネコトースター",rarity:3},{id:169,name:"アシルガ",rarity:4},{id:170,name:"クビルガ",rarity:4},{id:171,name:"テコルガ",rarity:4},{id:172,name:"バララガ",rarity:4},{id:197,name:"キャットマンダディ",rarity:4},{id:198,name:"サイキックネコ",rarity:2},{id:199,name:"ねこ陰陽師",rarity:2},{id:200,name:"ネコサーファー",rarity:3},{id:201,name:"メタルネコ",rarity:3},{id:238,name:"おかめはちもくネコ",rarity:3},{id:239,name:"ボンボンネコ",rarity:3},{id:240,name:"見習いスニャイパー",rarity:3},{id:241,name:"トゲルガ",rarity:4},{id:258,name:"天空神ゼウス",rarity:4},{id:259,name:"守護神アヌビス",rarity:4},{id:260,name:"美女神アフロディーテ",rarity:4},{id:272,name:"太陽神アマテラス",rarity:4},{id:273,name:"繁栄神ガネーシャ",rarity:4},{id:287,name:"閃雷機兵レイ",rarity:4},{id:308,name:"ネコジャンパー",rarity:3},{id:309,name:"ネコバサミ",rarity:2},{id:317,name:"海王神ポセイドン",rarity:4},{id:326,name:"ネコボクサー",rarity:2},{id:377,name:"ネコ探査機",rarity:2},{id:378,name:"ネコフェンシング",rarity:3},{id:440,name:"時空神クロノス",rarity:4},{id:444,name:"ネコ医師",rarity:2},{id:445,name:"ネコ占い師",rarity:2},{id:446,name:"ネコシャーマン",rarity:2},{id:447,name:"ネコ魔女",rarity:2},{id:448,name:"ネコアーチャー",rarity:2},{id:494,name:"竜騎士バルス",rarity:4},{id:496,name:"ネコパーフェクト",rarity:3},{id:523,name:"ネコ武闘家",rarity:2},{id:524,name:"ネコ法師",rarity:2},{id:535,name:"竜戦機ライデン",rarity:4},{id:643,name:"神龍かむくら",rarity:4},{id:724,name:"聖龍メギドラ",rarity:4},{id:812,name:"地龍ソドム",rarity:4}
        ];
        const fallbackEvents = [
            {id:992,name:"波動バスターズ",rare:7000,supa:2500,uber:500},
            {id:452,name:"エアバスターズ",rare:7000,supa:2500,uber:500},
            {id:523,name:"ギガントゼウス",rare:7000,supa:2500,uber:500}
        ];
        const fallbackGacha = [
            {id:992,cats:[812,724,643,535,494,440,317,273,272,260,259,258,448,447,446,445,444,201,145,132,130,238,239,240,524,523,496,378,377,326,308,309,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:452,cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:523,cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]}
        ];

        async function loadAndProcessData() {
            const loadedData = {};
            try {
                for (const file of dataFiles) {
                    const response = await fetch(file);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const text = await response.text();
                    const jsonStr = text.substring(text.indexOf('['), text.lastIndexOf(']') + 1);
                    loadedData[file.split('/')[1].split('.')[0]] = JSON.parse(jsonStr);
                }
            } catch (e) {
                console.warn("Failed to load external data, using fallback data.", e);
                loadedData.cats = fallbackCats;
                loadedData.events = fallbackEvents;
                loadedData.gacha = fallbackGacha;
            }

            const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
            const catsMaster = {};
            for (const cat of loadedData.cats) { catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" }; }
            const eventsMaster = {};
            for (const event of loadedData.events) { eventsMaster[event.id] = event; }
            const gachasMaster = {};
            for (const gacha of loadedData.gacha) {
                const eventInfo = eventsMaster[gacha.id];
                if (!eventInfo) continue;
                const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
                if (gacha.cats) {
                    for (const catId of gacha.cats) {
                        const catInfo = catsMaster[catId];
                        if (catInfo && pool[catInfo.rarity] !== undefined) pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
                    }
                }
                gachasMaster[gacha.id] = {
                    id: gacha.id.toString(),
                    name: eventInfo.name || gacha.name || `ガチャID: ${gacha.id}`,
                    rarity_rates: { rare: eventInfo.rare || 0, super: eventInfo.supa || 0, uber: eventInfo.uber || 0, legend: eventInfo.legend || 0 },
                    pool: pool
                };
            }
            gachaMasterData = { cats: catsMaster, gachas: gachasMaster };

            const urlParams = new URLSearchParams(window.location.search);
            const seedParam = urlParams.get('seed');
            const simConfigParam = urlParams.get('sim_config');
            const gachasParam = urlParams.get('gachas');

            if (gachasParam) {
                tableGachaIds = gachasParam.split('-');
            } else if (simConfigParam) {
                tableGachaIds = [];
            } else {
                const gachaKeys = Object.keys(gachaMasterData.gachas);
                if (gachaKeys.length > 0) tableGachaIds.push(gachaKeys[0]);
            }

            if (seedParam) {
                document.getElementById('seed').value = seedParam;
            }
            if (simConfigParam) {
                document.getElementById('sim-config').value = simConfigParam;
            }

            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();

            resetAndGenerateTable();
        }
        
        function updateSeedFromSim() {
            if (finalSeedForUpdate) {
                document.getElementById('seed').value = finalSeedForUpdate;
                document.getElementById('sim-config').value = ''; // sim-config をブランクにする
                resetAndGenerateTable(); 
            }
        }

        function addMoreRows(count) {
            currentRolls += count;
            generateRollsTable();
        }

        function resetAndGenerateTable() {
            finalSeedForUpdate = null;
            // sim-config がブランクの場合のみ currentRolls をリセット
            if (document.getElementById('sim-config').value.trim() === '') {
                 currentRolls = 100;
            }
            generateRollsTable();
        }

        function updateGachaSelection(selectElement, index) {
            const originalIdWithG = tableGachaIds[index];
            const isGuaranteed = originalIdWithG.endsWith('g');
            let newId = selectElement.value;
            if (isGuaranteed) {
                newId += 'g';
            }
            tableGachaIds[index] = newId;
            generateRollsTable();
        }

        function addGachaColumn() {
            const gachaKeys = Object.keys(gachaMasterData.gachas);
            if (gachaKeys.length > 0) {
                tableGachaIds.push(gachaKeys[0]);
                generateRollsTable();
            }
        }

        function removeGachaColumn(index) {
            tableGachaIds.splice(index, 1);
            generateRollsTable();
        }

        function toggleSeedColumns() {
            showSeedColumns = !showSeedColumns;
            generateRollsTable(); 
            updateToggleButtons();
        }

        function toggleResultDisplay() {
            showResultDisplay = !showResultDisplay;
            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();
        }
        function updateToggleButtons() {
            document.getElementById('toggle-seed-btn').textContent = showSeedColumns ? 'SEEDを非表示' : 'SEEDを表示';
            document.getElementById('toggle-result-btn').textContent = showResultDisplay ? '計算過程を非表示' : '計算過程を表示';
        }

        function updateUrlParams() {
            const seed = document.getElementById('seed').value;
            const simConfig = document.getElementById('sim-config').value;
            const urlParams = new URLSearchParams(window.location.search);

            if (seed) {
                urlParams.set('seed', seed);
            } else {
                urlParams.delete('seed');
            }
            if (simConfig) {
                urlParams.set('sim_config', simConfig);
            } else {
                urlParams.delete('sim_config');
            }
            if (tableGachaIds.length > 0) {
                urlParams.set('gachas', tableGachaIds.join('-'));
            } else {
                urlParams.delete('gachas');
            }

            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            window.history.pushState({path: newUrl}, '', newUrl);
        }

        class Xorshift32 { constructor(seed) { this.seed = (seed >>> 0) || 1; } next() { let x = this.seed; x ^= (x << 13); x ^= (x >>> 17); x ^= (x << 15); this.seed = x >>> 0; return this.seed; } }

        
        /**
         * 固定シード配列と開始インデックスを用いてガチャを一回実行し、シード消費を含む詳細を返す
         * @param {number} startIndex - seeds配列の開始インデックス
         * @param {object} gachaConfig - ガチャ設定
         * @param {number[]} seeds - 全シード値の配列
         * @param {object} lastDrawInfo - 直前のドロー情報 ({rarity, charId})
         * @returns {object} - ロール結果の詳細
         */
        function rollWithSeedConsumptionFixed(startIndex, gachaConfig, seeds, lastDrawInfo) {
            if (startIndex + 1 >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: null, s1: null, s2: null };
            
            // S0, S1, S2 are seeds[startIndex], seeds[startIndex+1], seeds[startIndex+2]
            const s0_seed = seeds[startIndex];
            const s1_seed = seeds[startIndex + 1];

            // Rarity Roll (based on S0)
            const rarityRoll = s0_seed % 10000;
            const rates = gachaConfig.rarity_rates || {};
            const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
            let currentRarity;
            if (rarityRoll < rareRate) { currentRarity = 'rare'; } else if (rarityRoll < rareRate + superRate) { currentRarity = 'super'; } else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber'; } else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend'; } else { currentRarity = 'rare'; }
            
            const characterPool = gachaConfig.pool[currentRarity] || [];
            if (characterPool.length === 0) {
                return { seedsConsumed: 2, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed, s1: s1_seed, s2: null };
            }
            
            // Character Roll (based on S1)
            const totalChars = characterPool.length;
            const charIndex = s1_seed % totalChars;
            let character = characterPool[charIndex];
            const originalChar = character;
            let seedsConsumed = 2;
            let isRerolled = false;
            let s2_seed = null;
            let reRollIndex = null;
            let uniqueTotal = null;

            if (currentRarity === 'rare' && lastDrawInfo && lastDrawInfo.rarity === 'rare' && lastDrawInfo.charId === character.id) {
                // Rare Dupe Check
                const uniqueRareChars = characterPool.filter(c => c.id !== lastDrawInfo.charId);
                uniqueTotal = uniqueRareChars.length;
                
                if (uniqueTotal > 0) {
                    // Reroll is possible (3 seeds consumed)
                    if (startIndex + 2 >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: s0_seed, s1: s1_seed, s2: null };
                    
                    s2_seed = seeds[startIndex + 2];
                    reRollIndex = s2_seed % uniqueTotal;
                    character = uniqueRareChars[reRollIndex];
                    isRerolled = true;
                    seedsConsumed = 3;
                } 
                // If uniqueTotal == 0, seedsConsumed remains 2, isRerolled remains false (unavoidable dupe).
            }
            
            return { 
                s0: s0_seed, s1: s1_seed, s2: s2_seed, 
                originalChar: originalChar, 
                finalChar: character, 
                isRerolled: isRerolled, 
                rarity: currentRarity, 
                charId: character.id, 
                charIndex: charIndex, 
                totalChars: totalChars, 
                uniqueTotal: uniqueTotal,
                reRollIndex: reRollIndex,
                seedsConsumed: seedsConsumed 
            };
        }

        function rollGuaranteedUber(startIndex, gachaConfig, seeds) {
            if (startIndex >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: 'uber', charId: null, s0: null };

            const s0_seed = seeds[startIndex];
            const currentRarity = 'uber';
            const characterPool = gachaConfig.pool[currentRarity] || [];
            const totalChars = characterPool.length;
            if (totalChars === 0) {
                return { seedsConsumed: 1, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed };
            }
            const charIndex = s0_seed % totalChars;
            const character = characterPool[charIndex];
            return { seedsConsumed: 1, finalChar: character, originalChar: character, isRerolled: false, rarity: currentRarity, charId: character.id, charIndex: charIndex, totalChars: totalChars, s0: s0_seed };
        }


        function calculateGuaranteedLookahead(startSeedIndex, gachaConfig, allSeeds, initialLastDraw) {
            if (!gachaConfig || !gachaConfig.pool['uber']) return { name: "N/A", nextSeed: null };

            let seedCursor = startSeedIndex;
            let lastDraw = initialLastDraw;
            let nextSimSeedValue = null;

            for (let i = 0; i < 10; i++) {
                if (seedCursor + 1 >= allSeeds.length) return { name: "N/A", nextSeed: null };

                const rollResult = rollWithSeedConsumptionFixed(seedCursor, gachaConfig, allSeeds, lastDraw);
                if (rollResult.seedsConsumed === 0) return { name: "N/A", nextSeed: null };
                
                seedCursor += rollResult.seedsConsumed;
                lastDraw = { rarity: rollResult.rarity, charId: rollResult.charId };
            }

            if (seedCursor >= allSeeds.length) return { name: "N/A", nextSeed: null };
            
            // Guaranteed roll (11th roll is 1-seed roll)
            const guaranteedRollResult = rollGuaranteedUber(seedCursor, gachaConfig, allSeeds);
            if (guaranteedRollResult.seedsConsumed === 0) return { name: "N/A", nextSeed: null };
            
            seedCursor += guaranteedRollResult.seedsConsumed;
            
            nextSimSeedValue = (seedCursor < allSeeds.length) ? allSeeds[seedCursor] : null;

            return { name: guaranteedRollResult.finalChar.name, nextSeed: nextSimSeedValue };
        }

        function toggleGuaranteedColumn(index) {
            const idWithG = tableGachaIds[index];
            if (idWithG.endsWith('g')) {
                tableGachaIds[index] = idWithG.slice(0, -1);
            } else {
                tableGachaIds[index] = idWithG + 'g';
            }
            generateRollsTable();
        }

        // --- sim-config ヘルパー関数 ---
        function parseSimConfig(configStr) {
            const configs = [];
            const parts = configStr.split('-');
            for (let i = 0; i < parts.length; i += 2) {
                const id = parts[i];
                const rollStr = parts[i+1];
                if (id && rollStr) {
                    const isGuaranteed = rollStr.endsWith('g');
                    const rolls = parseInt(rollStr.replace('g', ''), 10);
                    configs.push({ id, rolls, g: isGuaranteed });
                }
            }
            return configs;
        }

        function stringifySimConfig(configArr) {
            return configArr.map(c => `${c.id}-${c.rolls}${c.g ? 'g' : ''}`).join('-');
        }

        function incrementLastRoll(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length > 0) {
                const last = configs[configs.length - 1];
                if (!last.g) { 
                    last.rolls += 1;
                } else {
                    // 11gの次は1
                    configs.push({ id: last.id, rolls: 1, g: false });
                }
            }
            return stringifySimConfig(configs);
        }
        // --- ヘルパー関数 終了 ---


        function generateRollsTable() {
            try {
                if (Object.keys(gachaMasterData).length === 0) { return; }
                const initialSeed = parseInt(document.getElementById('seed').value, 10);
                const numRolls = currentRolls;
                if (isNaN(initialSeed) || isNaN(numRolls)) {
                    document.getElementById('rolls-table-container').innerHTML = '<p class="error">エラー: 有効な値を入力してください。</p>';
                    return;
                }
                
                // 3. シード値配列の定義と初期化
                const seeds = [];
                const rngForSeeds = new Xorshift32(initialSeed);
                // 最大のロール回数 * 3 + 20シード分を確保
                for (let i = 0; i < numRolls * 3 + 20; i++) { seeds.push(rngForSeeds.next()); }

                // 1. sim-config の処理
                const simConfigInput = document.getElementById('sim-config').value.trim();
                let simConfigs = [];
                let simGachaIds = new Set(); // ハイライト対象のガチャID
                let baseConfig = simConfigInput; 

                if (simConfigInput) {
                    simConfigs = parseSimConfig(simConfigInput);
                    simConfigs.forEach(sim => {
                        simGachaIds.add(sim.id);
                        if (gachaMasterData.gachas[sim.id]) {
                            sim.gachaConfig = gachaMasterData.gachas[sim.id];
                        }
                        
                        const gachaIdInTable = sim.g ? `${sim.id}g` : sim.id;
                        const hasGuaranteed = tableGachaIds.includes(`${sim.id}g`);

                        if (!tableGachaIds.includes(gachaIdInTable)) {
                            if (sim.g) {
                                tableGachaIds.push(gachaIdInTable);
                            } else {
                                if (!hasGuaranteed) {
                                    tableGachaIds.push(gachaIdInTable);
                                }
                            }
                        }
                    });
                } else if (tableGachaIds.length > 0) {
                    const firstGachaId = tableGachaIds[0].replace('g', '');
                    if (gachaMasterData.gachas[firstGachaId]) {
                        const defaultSimStr = `${firstGachaId}-100`;
                        simConfigs = parseSimConfig(defaultSimStr);
                        simConfigs[0].gachaConfig = gachaMasterData.gachas[firstGachaId];
                        simGachaIds.add(firstGachaId);
                    }
                    baseConfig = '';
                }
                
                const uniqueGachaIds = [...new Set(tableGachaIds.map(id => id.replace('g', '')))];
                const gachaConfigs = uniqueGachaIds.map(id => gachaMasterData.gachas[id]).filter(Boolean);


                // 2. シミュレーション実行 (ハイライトと計算過程のため)
                const simulationResults = [];
                const highlightMap = new Map(); // key 'row-track' -> 'gachaId'
                
                const rngForText = new Xorshift32(initialSeed);
                let lastDrawForText = { rarity: null, charId: null };

                let seedCursor = 0;
                let lastDrawForHighlight = { rarity: null, charId: null };
                let totalSimRolls = 0;

                if (simConfigs.length > 0) {
                    for (const sim of simConfigs) {
                        if (!sim.gachaConfig) continue; 

                        if (sim.g && sim.rolls === 11) {
                            // 11連確定 (10+1ロール)
                            for (let i = 0; i < 10; i++) {
                                const row = Math.floor(seedCursor / 2);
                                const track = (seedCursor % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                
                                highlightMap.set(`${row}-${track}`, sim.id);
                                
                                const rollResult = rollWithSeedConsumptionFixed(seedCursor, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;
                                
                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                seedCursor += rollResult.seedsConsumed;

                                const resultForText = rollWithSeedConsumptionFixed(0, sim.gachaConfig, [rngForText.next(), rngForText.next(), rngForText.next()], lastDrawForText); 
                                // rngForText.next()を呼び出すことでシードを消費させる（結果の詳細はrollResultにある）
                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                
                                simulationResults.push({ ...sim, result: rollResult, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                                lastDrawForText = { rarity: rollResult.rarity, charId: rollResult.charId };
                            }
                            // 11回目（確定）
                            const row = Math.floor(seedCursor / 2);
                            const track = (seedCursor % 2 === 0) ? 'A' : 'B';
                            
                            const guaranteedResult = rollGuaranteedUber(seedCursor, sim.gachaConfig, seeds);
                            if (guaranteedResult.seedsConsumed === 0) break;

                            seedCursor += guaranteedResult.seedsConsumed;
                            rngForText.next(); // 1 seed consume

                            simulationResults.push({ ...sim, result: guaranteedResult, track: track, isGuaranteed: true, rollNum: ++totalSimRolls });
                            lastDrawForText = guaranteedResult;
                            
                        } else {
                            // 通常ロール
                            for (let i = 0; i < sim.rolls; i++) {
                                const row = Math.floor(seedCursor / 2);
                                const track = (seedCursor % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                highlightMap.set(`${row}-${track}`, sim.id);

                                const rollResult = rollWithSeedConsumptionFixed(seedCursor, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;

                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                seedCursor += rollResult.seedsConsumed;

                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                
                                simulationResults.push({ ...sim, result: rollResult, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                                lastDrawForText = { rarity: rollResult.rarity, charId: rollResult.charId };
                            }
                        }
                    }
                }
                finalSeedForUpdate = rngForText.seed;
                
                // 3. テーブルデータと全ロール結果の準備
                const tableData = Array(numRolls).fill(null).map(() => ({ A: [], B: [] }));
                const fullRollResults = new Map(); // key 'A-i-id' or 'B-i-id' -> full roll result
                
                gachaConfigs.forEach((config, gachaIndex) => {
                    if (!config) return;
                    let prevDrawA = { rarity: null, charId: null };
                    let prevDrawB = { rarity: null, charId: null };

                    for (let i = 0; i < numRolls; i++) {
                        // --- Track A ---
                        const rollResultA = rollWithSeedConsumptionFixed(i * 2, config, seeds, prevDrawA);
                        const cellKeyA = `A-${i}-${config.id}`;
                        fullRollResults.set(cellKeyA, rollResultA);
                        tableData[i].A[gachaIndex] = { gachaId: config.id, roll: rollResultA };
                        prevDrawA = { rarity: rollResultA.rarity, charId: rollResultA.charId };

                        // --- Track B ---
                        const rollResultB = rollWithSeedConsumptionFixed(i * 2 + 1, config, seeds, prevDrawB);
                        const cellKeyB = `B-${i}-${config.id}`;
                        fullRollResults.set(cellKeyB, rollResultB);
                        tableData[i].B[gachaIndex] = { gachaId: config.id, roll: rollResultB };
                        prevDrawB = { rarity: rollResultB.rarity, charId: rollResultB.charId };
                        
                        if (i * 2 + 3 >= seeds.length) break; 
                    }
                });


                // 4. リンク(sim-config)マップの計算
                
                let startSeedIndex = seedCursor;
                let startRow = Math.floor(startSeedIndex / 2);
                let startTrack = (startSeedIndex % 2 === 0) ? 'A' : 'B';
                let newRow1Index = startRow; 
                
                if (baseConfig === '') {
                    newRow1Index = 0;
                    startTrack = 'A';
                }
                
                const cellSimConfigs = new Map(); // key 'A-i-id' -> "sim-config-string" or null
                
                // === ローカルヘルパー関数定義 ===
                const getCellDataFull = (track, row, gachaId) => {
                    const key = `${track}-${row}-${gachaId}`;
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === gachaId);

                    if (row < 0 || row >= numRolls || gachaIndex === -1 || !tableData[row] || !tableData[row][track][gachaIndex]) {
                        return { config: cellSimConfigs.get(key) || null, roll: null, seedsConsumed: 0 };
                    }
                    
                    const roll = tableData[row][track][gachaIndex].roll;
                    return {
                        config: cellSimConfigs.get(key) || null,
                        roll: roll,
                        seedsConsumed: roll.seedsConsumed,
                    };
                };
                
                const getPrevData = (track, i, gachaId) => getCellDataFull(track, i - 1, gachaId);
                const getPrevPrevCrossTrackData = (crossTrack, i, gachaId) => getCellDataFull(crossTrack, i - 2, gachaId);
                // === ローカルヘルパー関数定義 終了 ===

                for (let i = 0; i < numRolls; i++) {
                    gachaConfigs.forEach(config => {
                        const id = config.id;
                        let configA = null;
                        let configB = null;

                        // ロールデータ取得 (i-1行目, i-2行目の情報)
                        const prevA = getPrevData('A', i, id);
                        const prevB = getPrevData('B', i, id);

                        if (i < newRow1Index) {
                            // --- FIXEDゾーン ---
                            if (i === 0) {
                                configA = `${id}-1`;
                                configB = null;
                            } else {
                                // A-i Logic (A -> A)
                                if (prevA.config) { 
                                    if (prevA.seedsConsumed <= 2) { configA = incrementLastRoll(prevA.config); } 
                                    else { configA = null; } // 3シード消費でリンク切断
                                } 
                                if (!configA && prevA.config === null) { configA = null; }

                                // B-i Logic (B -> B)
                                if (prevB.config) { 
                                    if (prevB.seedsConsumed <= 2) { configB = incrementLastRoll(prevB.config); } 
                                    else { configB = null; } // 3シード消費でリンク切断
                                }
                                // B-i Logic (A -> B)
                                if (!configB && prevB.config === null) { 
                                    if (prevA.config && prevA.seedsConsumed === 3) {
                                        configB = incrementLastRoll(prevA.config); 
                                    } else { configB = null; }
                                }
                            }
                        } else if (i === newRow1Index) {
                            // --- "新しい1行目" (FIX & Continueの開始点) ---
                            if (startTrack === 'A') {
                                configA = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                                configB = null; 
                            } else { // startTrack === 'B'
                                configA = null; 
                                configB = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                            }
                        } else {
                            // --- "新しい2行目" 以降 (CONTINUE) ---
                            
                            // A-i Logic (Same Track Continuation)
                            if (prevA.config) { 
                                if (prevA.seedsConsumed <= 2) { configA = incrementLastRoll(prevA.config); } 
                                else { configA = null; } 
                            } 
                            
                            // A-i Logic (B -> A) 
                            if (!configA) { 
                                const prevPrevB = getPrevPrevCrossTrackData('B', i, id);
                                if (prevPrevB.config && prevPrevB.seedsConsumed === 3) {
                                    configA = incrementLastRoll(prevPrevB.config);
                                } else { configA = null; }
                            }

                            // B-i Logic (Same Track Continuation)
                            if (prevB.config) { 
                                if (prevB.seedsConsumed <= 2) { configB = incrementLastRoll(prevB.config); } 
                                else { configB = null; }
                            }
                            
                            // B-i Logic (A -> B) 
                            if (!configB) { 
                                const prevA_for_B = getPrevData('A', i, id);
                                if (prevA_for_B.config && prevA_for_B.seedsConsumed === 3) {
                                    configB = incrementLastRoll(prevA_for_B.config); 
                                } else { configB = null; }
                            }
                        } 

                        cellSimConfigs.set(`A-${i}-${id}`, configA);
                        cellSimConfigs.set(`B-${i}-${id}`, configB);
                    }); 
                }
                // --- リンク(sim-config)マップの計算 終了 ---


                // 5. HTMLテーブルの構築
                const buttonHtml = `<button class="add-gacha-btn" onclick="addGachaColumn()">＋</button>`;
                let totalColsA = 0;
                tableGachaIds.forEach(idWithG => {
                    const id = idWithG.replace('g', '');
                    if (gachaMasterData.gachas[id]) {
                        totalColsA += idWithG.endsWith('g') ? 2 : 1;
                    }
                });
                
                const seedColClass = `seed-column ${showSeedColumns ? '' : 'hidden'}`;

                let tableHtml = `<table><thead>
                    <tr>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th rowspan="2" class="${seedColClass}">SEED 1</th>
                        <th rowspan="2" class="${seedColClass}">SEED 2</th>
                        <th colspan="${totalColsA}">A ${buttonHtml}</th>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th rowspan="2" class="${seedColClass}">SEED 1</th>
                        <th rowspan="2" class="${seedColClass}">SEED 2</th>
                        <th colspan="${totalColsA}">B</th>
                    </tr>
                    <tr>`;
                
                // Headers for Track A and B
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;

                    const removeButtonHtml = `<button onclick="removeGachaColumn(${index})">x</button>`;
                    const gButtonHtml = `<button onclick="toggleGuaranteedColumn(${index})">G</button>`;
                    let selectorHtml = `<select onchange="updateGachaSelection(this, ${index})">`;
                    Object.keys(gachaMasterData.gachas).forEach(gachaId => {
                        selectorHtml += `<option value="${gachaId}" ${gachaId === id ? 'selected' : ''}>${gachaMasterData.gachas[gachaId].name}</option>`;
                    });
                    selectorHtml += '</select>';
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;

                    if (isGuaranteed) {
                        tableHtml += `<th colspan="2"><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    } else {
                        tableHtml += `<th><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    }
                });

                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;

                    if (isGuaranteed) {
                        tableHtml += `<th colspan="2">${headerName}</th>`;
                    } else {
                        tableHtml += `<th>${headerName}</th>`;
                    }
                });

                tableHtml += `</tr></thead><tbody>`;

                // --- セルコンテンツ生成ロジックのヘルパー関数 ---
                function generateCellContent(track, i, id, isGuaranteedColumn) {
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                    if (gachaIndex === -1 || !tableData[i] || !tableData[i][track][gachaIndex] || !tableData[i][track][gachaIndex].roll) return 'N/A';
                    
                    const fullRoll = tableData[i][track][gachaIndex].roll;
                    const configStr = cellSimConfigs.get(`${track}-${i}-${id}`);
                    const highlightClass = (highlightMap.get(`${i}-${track}`) === id) ? ' highlight' : '';
                    let cellContent = '';
                    
                    // 1. Next Cell Address/Link Calculation
                    let nextAddress = null;
                    let linkHref = configStr;

                    if (fullRoll.seedsConsumed === 3) {
                        // 3シード消費: A(i) -> B(i+1) or B(i) -> A(i+2)
                        const destTrack = (track === 'A' ? 'B' : 'A');
                        const destRow = (track === 'A' ? i + 1 : i + 2);
                        if (destRow < numRolls && linkHref) {
                            nextAddress = `${destRow + 1}${destTrack})`;
                        }
                    } 
                    // 2シード消費は nextAddress = null (Rule 2)

                    if (fullRoll.isRerolled) {
                        // Rule 3: Rare Dupe Avoided (3-seed roll)
                        const originalCharName = fullRoll.originalChar.name;
                        const rerollCharName = fullRoll.finalChar.name;
                        
                        let rerollDisplay = rerollCharName;
                        if (linkHref) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(linkHref)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${linkHref}'; resetAndGenerateTable();`;
                            // Rule 3: Prefix with address if link exists
                            rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${rerollCharName}</a>`;
                        }
                        
                        cellContent = `${originalCharName}<br>${nextAddress ? nextAddress + ' ' : ''}${rerollDisplay}`;
                        
                    } else {
                        // Normal roll (1 or 2 seeds) or unavoidable rare dupe (2 seeds)
                        cellContent = fullRoll.finalChar.name;
                        
                        if (linkHref) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(linkHref)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${linkHref}'; resetAndGenerateTable();`;
                            
                            // Next address is only displayed for cross-track links
                            cellContent = `<a href="${href}" onclick="${onclickAction}">${nextAddress ? nextAddress + ' ' : ''}${fullRoll.finalChar.name}</a>`;
                        } else if (nextAddress) {
                            // Link propagation is broken, but nextAddress was calculated (should not happen with current logic)
                            cellContent = `${nextAddress} ${fullRoll.finalChar.name}`;
                        }
                    }

                    return `<td class="gacha-cell${highlightClass}">${cellContent}</td>`;
                }
                // --- ヘルパー関数 終了 ---


                for (let i = 0; i < numRolls; i++) {
                    let rowHtml = `<tr><td class="col-no">${i + 1}</td>`;
                    rowHtml += `<td class="${seedColClass}">${seeds[2 * i]}</td><td class="${seedColClass}">${seeds[2 * i + 1]}</td>`;
                    
                    // Track A Cells
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteed = idWithG.endsWith('g');
                        const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return; 
                        
                        // Normal A roll
                        rowHtml += generateCellContent('A', i, id, false);
                        
                        if (isGuaranteed) {
                            // Guaranteed column (G)
                            let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)] && tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll) ? { rarity: tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll.charId } : null;
                            const { name: guaranteedChar, nextSeed } = calculateGuaranteedLookahead(i * 2, gachaConfig, seeds, lastDraw);
                            
                            let guaranteedHighlight = '';
                            let content = guaranteedChar;
                            
                            // G列のリンクは、A列がリンクの場合のみ生成 (sim-config 10 -> 11g)
                            const configStrA = cellSimConfigs.get(`A-${i}-${id}`);
                            if (configStrA) {
                                const parsedA = parseSimConfig(configStrA);
                                const lastPartA = parsedA.pop();
                                
                                if (lastPartA && lastPartA.rolls > 0) { 
                                    lastPartA.rolls -= 1;
                                    if (lastPartA.rolls > 0) parsedA.push(lastPartA);
                                    parsedA.push({ id: id, rolls: 11, g: true });
                                    const configG_A = stringifySimConfig(parsedA);

                                    const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_A)}&gachas=${tableGachaIds.join('-')}`;
                                    const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_A}'; resetAndGenerateTable();`;
                                    content = `<a href="${hrefG}" onclick="${onclickActionG}">${guaranteedChar}</a>`;
                                }
                            }
                            
                            rowHtml += `<td${guaranteedHighlight}>${content}</td>`;
                        }
                    });

                    rowHtml += `<td class="col-no">${i + 1}</td>`;
                    rowHtml += `<td class="${seedColClass}">${seeds[2 * i + 1]}</td><td class="${seedColClass}">${seeds[2 * i + 2]}</td>`;

                    // Track B Cells
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteed = idWithG.endsWith('g');
                        const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return;

                        // Normal B roll
                        rowHtml += generateCellContent('B', i, id, false);

                        if (isGuaranteed) {
                             // Guaranteed column (G)
                             let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)] && tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll) ? { rarity: tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll.charId } : null;
                             const { name: guaranteedChar, nextSeed } = calculateGuaranteedLookahead(i * 2 + 1, gachaConfig, seeds, lastDraw);
                             
                             let guaranteedHighlight = '';
                             let content = guaranteedChar;
                             
                             const configStrB = cellSimConfigs.get(`B-${i}-${id}`);
                             if (configStrB) {
                                const parsedB = parseSimConfig(configStrB);
                                const lastPartB = parsedB.pop();
                                
                                if(lastPartB && lastPartB.rolls > 0) {
                                    lastPartB.rolls -= 1;
                                    if (lastPartB.rolls > 0) parsedB.push(lastPartB);
                                    parsedB.push({ id: id, rolls: 11, g: true });
                                    const configG_B = stringifySimConfig(parsedB);
                                    
                                    const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_B)}&gachas=${tableGachaIds.join('-')}`;
                                    const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_B}'; resetAndGenerateTable();`;
                                    content = `<a href="${hrefG}" onclick="${onclickActionG}">${guaranteedChar}</a>`;
                                }
                             }
                             
                             rowHtml += `<td${guaranteedHighlight}>${content}</td>`;
                        }
                    });
                    
                    rowHtml += `</tr>`;
                    tableHtml += rowHtml;
                }

                tableHtml += '</tbody></table>';
                document.getElementById('rolls-table-container').innerHTML = tableHtml;

                let simulationOutputString = '--- シミュレーション詳細 ---\n';
                if (simulationResults.length > 0) {
                    simulationResults.forEach((sim, index) => {
                        if (!sim || !sim.result) return;
                        const result = sim.result;
                        let line;
                        if (sim.isGuaranteed) {
                             line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | uber guaranteed ${result.s0} ${result.finalChar.name}`;
                        } else {
                            line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | ${result.s0}(${result.rarity})${result.rarity}`;
                            if (result.isRerolled) {
                                line += ` ${result.originalChar.name} -> ${result.s2} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            } else {
                                line += `／${result.s1} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            }
                        }
                        simulationOutputString += line + '\n';
                    });
                }
                document.getElementById('result').textContent = simulationOutputString;

                updateUrlParams();
            } catch (e) {
                document.getElementById('rolls-table-container').innerHTML = `<p class="error">テーブルの生成中にエラーが発生しました: ${e.message}</p>`;
                document.getElementById('result').textContent = `エラー: ${e.stack}`; // エラー詳細を表示
                console.error(e);
            }
        }

        window.onload = loadAndProcessData;
    </script>
</body>
</html>
